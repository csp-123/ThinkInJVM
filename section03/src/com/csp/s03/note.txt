第3章 垃圾收集器与内存分配策略

    3.2 对象已死吗?
        3.2.1 引用计数算法
            为每个对象添加引用计数器, 增加引用则+1, 减少引用则-1, 为0时改对象不能再被引用.
            缺陷: 相互循环引用问题.

        3.2.2 可达性分析算法
            当对象没有任何引用链与GC Roots相连, 则此对象不可用.

        3.2.3 再谈引用
            强引用(String Reference) : 类似Object o = new Object()的引用, 只要强引用还在, 就不会被GC回收.
            软引用(Soft Reference) : 描述一些还有用但非必须的对象. 在系统发生内存溢出之前, 将会把这些对象列
                入回收范围进行第二次回收, 若还没有足够内存才会抛出异常.
            弱引用(Weak Reference) : 描述非必须对象,它的强度比软引用更弱一些, 当垃圾收集器工作时, 无论当前内存是否足够, 都会回收对象.
            虚引用(Phantom Reference) : 最弱的引用, 它的存在不会影响对象的生存时间, 也不能通过虚引用来获取对象实例, 它唯一作用就是在
                对象被回收时收到一个系统通知.

        3.2.4 生存还是死亡

        3.2.5 回收方法区
            永久代的垃圾收集主要回收两部分内容: 废弃常量和无用的类
            回收无用的类需要满足3个条件:
                1. 该类的所有实例都已经被回收
                2. 加载该类的ClassLoader已经被回收
                3. 该类对应的Java.lang.Class对象没有在任何地方被引用, 无法再任何地方通过反射来访问该类的方法

    3.3 垃圾收集算法
        3.3.1 标记-清除算法
            不足: 效率不高, 产生大量内存碎片
        3.3.2 复制算法
            不足: 内存空间只剩原来一半
        3.3.3 标记整理算法
        3.3.4 分代收集算法

    3.4 HotSpot虚拟机的算法实现

    3.5 垃圾收集器

    3.6 内存分配与回收策略
        3.6.1 对象优先在Eden中分配
            PrintGCDetail.java
            VM 参数: -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
            java堆大小为20M不可扩展 新生代大小10M
        3.6.2 大对象直接进入老年代
            写Java代码要避免生命周期很短的大对象.
            -XX:PretenureSizeThreshold=3145728
            大于3M的对象直接进入老年代.
            这个参数只对Serial和ParNew两款收集器有效.
        3.6.3 长期存活的对象将进入老年代
            -XX:MaxTenuringThreshold=15
            该参数控制对象晋升到老年代的阈值

        3.6.4 动态对象年龄判定
        3.6.5 空间分配担保
            -XX:HandlePromotionFailure

