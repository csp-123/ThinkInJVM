第二章 Java内存区域与内存溢出异常

    2.2 运行时数据区域
        2.2.1 程序计数器
            程序计数器是一块较小的内存空间, 它可以看做是当前线程所执行的字节码行号指示器.
            该区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域.

        2.2.2 Java虚拟机栈
            Java虚拟机栈也是线程私有的, 它的生命周期与线程相同. 虚拟机栈为虚拟机执行Java方法服务.

        2.2.3 本地方法栈
            本地方法栈则为虚拟机使用到的Native方法服务

        2.2.4 Java堆
            Java堆用于存放对象实例和数组. 因是垃圾收集主要管理的区域,故也称GC堆.

        2.2.5 方法区
            用于存储已被虚拟机加载的类信息, 常量, 静态变量, 即时编译器编译的代码等信息

        2.2.6 运行时常量池
            运行时常量池是方法区的一部分. 用于存放各种编译期生成的各种字面量和符号引用.

        2.2.7 直接内存
            直接内存并不是虚拟机运行时的数据区的一部分, 也不是Java虚拟机规范中定义的内存区域.

    2.3 HotSpot虚拟机对象探秘
        2.3.1 对象的创建
            内存分配方式有两种:
            指针碰撞: 假设Java堆中的内存是绝对规整的, 所有对象分配内存只需把作为分界点的指示器向空闲内存区域移动一段与对象大小相等的内存区域.
            空闲列表: 假设Java堆中的内存是不是规整的, 虚拟机维护一个列表记录可用内存块, 分配后更新空闲列表.

            解决内存分配的线程安全问题有两种:
            一种保证对分配内存空间的动作进行同步处理---实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性.
            另一种是把内存分配的的动作按照线程划分在不同的空间中进行, 即每个线程预先在Java堆中预先分配一小块内存, 称为本地线程分配缓冲(TLAB)

        2.3.2 对象的内存布局
            在HotSpot虚拟机中, 对象在内存中存储的布局可以分为3块区域: 对象头, 实例数据, 对齐填充.

        2.3.3 对象的访问定位
            对象的两种主流访问方式:句柄访问和直接指针

    2.4 实战: OutOfMemoryError异常
        2.4.1 Java堆溢出
            Java堆用于存储对象实例, 只要不断创建对象, 并且保证GC Roots到对象之间有可达路径来避免被回收, 当对象数量到最大堆容量限制后就会产生内存溢出.

        2.4.2 虚拟机栈和本地方法栈溢出
            如果线程请求的栈深度大于虚拟机所允许的最大深度, 将抛出StackOverflowError异常.

        2.4.3 方法区和运行时常量池溢出

        2.4.4 本机直接内存溢出