第12章 Java内存模型与线程

    12.3 java内存模型
        12.3.1 主内存和工作内存
            Java内存模型规定所有的变量都存储在主内存中（此处主内存是虚拟机内存的一部分）。
            每条线程拥有自己的工作内存，保存了被该线程使用到的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行。
            不同线程之间也无法访问对方工作线程，线程间变量传递均需要通过主内存来完成。

        12.3.2 内存间交互操作
            主内存和工作内存的交互
            Java内存模型定义了8种原子操作来完成

            lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占状态。
            unlock（解锁）：作用于主内存的变量，解锁后的变量才可以被别的线程锁定。
            read（读取）：作用于主内存变量，把变量的值从主内存传输到线程的工作内存中，以便后续的load动作使用。
            load（载入）：作用于工作内存的变量，它把read操作的值放入到工作内存的变量副本中。
            use（使用）：作用于工作内存的变量，它把一个变量的值传递给执行引擎。
            assign（赋值）：作用于工作内存的变量，把一个从执行引擎接收到的值赋给工作内存的变量。
            store（存储）：作用于工作内存的变量，它把工作内存一个变量的值传递给主内存中以便后续的write操作使用。
            write（写入）：作用于主内存变量，它把store操作从工作内存得到的变量的值放入主内存的变量中。

            Java内存模型还规定8种基本操作时必须满足如下规则：p386

        12.3.3 对于volatile型变量的特殊规则
            volatile变量只能保证可见性，要想保证并发安全性，要遵循以下两条规则：
            1. 运算结果并不依赖变量当前值，或者能够确保只有单一线程修改变量的值
            2. 变量不需要与其他的状态变量共同参与不变约束

        12.3.4 对long和double型变量的特殊规则
            long和double非原子协定

        12.3.5 原子性, 可见性与有序性

        12.3.6 先行发生原则
            时间先后顺序与先行发生原则之间基本没有太大的关系, 所以我们衡量并发安全问题的时候不要受到时间顺序的干扰,
            一切必须以先行发生原则为准.

    12.4 java与线程
        12.4.1 线程的实现
            1. 使用内核线程实现
            2. 使用用户线程实现
            3. 使用用户线程加轻量级进程混合实现
            4. java线程的实现

        12.4.2 java线程的调度
            协同式线程调度

            抢占式线程调度

        12.4.3 状态转换
